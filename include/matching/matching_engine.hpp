#ifndef MATCHING_ENGINE_HPP
#define MATCHING_ENGINE_HPP

#include "order_book.hpp"
#include <cstdint>
#include <vector>
#include <memory>
#include <chrono>
#include <functional>
#include <optional>
#include <unordered_map>
#include <atomic>

namespace matching {

// Core types
using OrderId = uint64_t;
using SymbolId = uint16_t; 
using Price = uint32_t;     // Price in 0.0001 units (e.g., 50000 = $5.00)
using Quantity = uint32_t;
using Timestamp = std::chrono::high_resolution_clock::time_point;

// Order side enumeration
enum class Side : char {
    BUY = 'B',
    SELL = 'S'
};

// Order types for MVP
enum class OrderType : char {
    MARKET = '1',    // Market order - execute immediately at market price
    LIMIT = '2'      // Limit order - execute only at specified price or better
};

// Time in force 
enum class TimeInForce : char {
    DAY = '0',       // Good for day
    IOC = '3',       // Immediate or Cancel  
    FOK = '4'        // Fill or Kill
};

// Order status
enum class OrderStatus : char {
    NEW = '0',           // Order accepted
    PARTIALLY_FILLED = '1', // Partially filled
    FILLED = '2',        // Fully filled  
    CANCELED = '4',      // Canceled
    REJECTED = '8'       // Rejected
};

// Core order structure
struct Order {
    OrderId id{0};
    SymbolId symbol{0};
    Side side{Side::BUY};
    OrderType type{OrderType::LIMIT};
    TimeInForce tif{TimeInForce::DAY};
    Quantity quantity{0};
    Quantity filled_quantity{0};  // How much has been filled
    Price price{0};               // Limit price (0 for market orders)
    Timestamp timestamp{};        // Order creation time
    OrderStatus status{OrderStatus::NEW};
    
    // Helper methods
    Quantity remaining_quantity() const { return quantity - filled_quantity; }
    bool is_fully_filled() const { return filled_quantity >= quantity; }
    bool is_buy() const { return side == Side::BUY; }
    bool is_sell() const { return side == Side::SELL; }
};

// Fill/Trade information
struct Fill {
    OrderId aggressive_order_id{0};  // Order that initiated the trade
    OrderId passive_order_id{0};     // Resting order that got hit
    SymbolId symbol{0};
    Price execution_price{0};        // Price at which trade occurred
    Quantity execution_quantity{0};  // Quantity traded
    Timestamp execution_time{};      // When the trade happened
    
    // For market data and reporting
    uint64_t trade_id{0};           // Unique trade identifier
};

// Match result from processing an order
struct MatchResult {
    OrderStatus final_status{OrderStatus::NEW};
    std::vector<Fill> fills;         // All fills generated by this order
    Quantity total_filled{0};        // Total quantity filled
    
    bool has_fills() const { return !fills.empty(); }
    bool is_fully_filled() const { return final_status == OrderStatus::FILLED; }
};

// Callback for when fills occur
using FillCallback = std::function<void(const Fill& fill)>;

// Market data snapshot
struct Level1Data {
    SymbolId symbol{0};
    Price best_bid_price{0};
    Quantity best_bid_quantity{0};
    Price best_ask_price{0};
    Quantity best_ask_quantity{0};
    Timestamp update_time{};
};

// Level 2 market data (market depth)
struct PriceLevel {
    Price price{0};
    Quantity quantity{0};
    uint32_t order_count{0};  // Number of orders at this price
};

struct Level2Data {
    SymbolId symbol{0};
    std::vector<PriceLevel> bids;    // Sorted by price descending
    std::vector<PriceLevel> asks;    // Sorted by price ascending  
    Timestamp update_time{};
};

// Main Matching Engine class
class MatchingEngine {
private:
    // Symbol-specific order books  
    std::unordered_map<SymbolId, std::unique_ptr<UltraOrderBook>> order_books_;
    
    // Order tracking
    std::unordered_map<OrderId, Order> active_orders_;
    
    // Trade ID generation
    std::atomic<uint64_t> next_trade_id_{1};
    
    // Callbacks
    FillCallback fill_callback_;
    
    // Internal helper methods
    MatchResult process_market_order(Order& order);
    MatchResult process_limit_order(Order& order);
    MatchResult attempt_cross(Order& aggressive_order, UltraOrderBook& book);
    Fill create_fill(const Order& aggressive, const Order& passive, Price price, Quantity qty);
    void update_order_status(Order& order);
    UltraOrderBook* get_or_create_book(SymbolId symbol);
    
public:
    explicit MatchingEngine(FillCallback callback = nullptr);
    ~MatchingEngine() = default;
    
    // Core order processing
    MatchResult process_order(Order order);
    bool cancel_order(OrderId order_id);
    bool replace_order(OrderId old_id, Order new_order);
    
    // Symbol management
    void add_symbol(SymbolId symbol);
    void remove_symbol(SymbolId symbol);
    std::vector<SymbolId> get_active_symbols() const;
    
    // Market data  
    Level1Data get_level1_data(SymbolId symbol) const;
    Level2Data get_level2_data(SymbolId symbol, uint32_t depth = 10) const;
    
    // Order query
    std::optional<Order> get_order(OrderId order_id) const;
    std::vector<Order> get_orders_for_symbol(SymbolId symbol) const;
    
    // Statistics
    struct Stats {
        uint64_t total_orders_processed{0};
        uint64_t total_fills{0}; 
        uint64_t total_volume{0};
        uint32_t active_symbols{0};
        uint32_t active_orders{0};
    };
    Stats get_stats() const;
    
    // Callback management
    void set_fill_callback(FillCallback callback) { fill_callback_ = std::move(callback); }
};

} // namespace matching

#endif // MATCHING_ENGINE_HPP
